// Code generated by protoc-gen-go. DO NOT EDIT.
// source: meepo.proto

package meepo_pb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0acbb0c07d5827b, []int{0}
}

func (m *Empty) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Empty.Unmarshal(m, b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return xxx_messageInfo_Empty.Size(m)
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type UsageByClass struct {
	// storage class -> used bytes
	Standard             int64    `protobuf:"varint,1,opt,name=standard,proto3" json:"standard,omitempty"`
	ReducedRedundancy    int64    `protobuf:"varint,2,opt,name=reducedRedundancy,proto3" json:"reducedRedundancy,omitempty"`
	Glacier              int64    `protobuf:"varint,3,opt,name=glacier,proto3" json:"glacier,omitempty"`
	StandardIA           int64    `protobuf:"varint,4,opt,name=standardIA,proto3" json:"standardIA,omitempty"`
	OneZoneIA            int64    `protobuf:"varint,5,opt,name=oneZoneIA,proto3" json:"oneZoneIA,omitempty"`
	IntelligentTiering   int64    `protobuf:"varint,6,opt,name=intelligentTiering,proto3" json:"intelligentTiering,omitempty"`
	DeepArchive          int64    `protobuf:"varint,7,opt,name=deepArchive,proto3" json:"deepArchive,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UsageByClass) Reset()         { *m = UsageByClass{} }
func (m *UsageByClass) String() string { return proto.CompactTextString(m) }
func (*UsageByClass) ProtoMessage()    {}
func (*UsageByClass) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0acbb0c07d5827b, []int{1}
}

func (m *UsageByClass) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UsageByClass.Unmarshal(m, b)
}
func (m *UsageByClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UsageByClass.Marshal(b, m, deterministic)
}
func (m *UsageByClass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageByClass.Merge(m, src)
}
func (m *UsageByClass) XXX_Size() int {
	return xxx_messageInfo_UsageByClass.Size(m)
}
func (m *UsageByClass) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageByClass.DiscardUnknown(m)
}

var xxx_messageInfo_UsageByClass proto.InternalMessageInfo

func (m *UsageByClass) GetStandard() int64 {
	if m != nil {
		return m.Standard
	}
	return 0
}

func (m *UsageByClass) GetReducedRedundancy() int64 {
	if m != nil {
		return m.ReducedRedundancy
	}
	return 0
}

func (m *UsageByClass) GetGlacier() int64 {
	if m != nil {
		return m.Glacier
	}
	return 0
}

func (m *UsageByClass) GetStandardIA() int64 {
	if m != nil {
		return m.StandardIA
	}
	return 0
}

func (m *UsageByClass) GetOneZoneIA() int64 {
	if m != nil {
		return m.OneZoneIA
	}
	return 0
}

func (m *UsageByClass) GetIntelligentTiering() int64 {
	if m != nil {
		return m.IntelligentTiering
	}
	return 0
}

func (m *UsageByClass) GetDeepArchive() int64 {
	if m != nil {
		return m.DeepArchive
	}
	return 0
}

type Job struct {
	Timestamp uint64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Id        int64  `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	StartKey  []byte `protobuf:"bytes,3,opt,name=startKey,proto3" json:"startKey,omitempty"`
	EndKey    []byte `protobuf:"bytes,4,opt,name=endKey,proto3" json:"endKey,omitempty"`
	/// response parameters:
	// bucket name -> storage class usages, returned results
	Usage map[string]*UsageByClass `protobuf:"bytes,5,rep,name=usage,proto3" json:"usage,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// job error, empty string for no error
	Error string `protobuf:"bytes,6,opt,name=error,proto3" json:"error,omitempty"`
	// how many keys processed
	Entries int64 `protobuf:"varint,7,opt,name=entries,proto3" json:"entries,omitempty"`
	/// for bookkeeping in registry:
	// which meepo this job is supposed to run on, IP address
	Meepo                string   `protobuf:"bytes,8,opt,name=meepo,proto3" json:"meepo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Job) Reset()         { *m = Job{} }
func (m *Job) String() string { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()    {}
func (*Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0acbb0c07d5827b, []int{2}
}

func (m *Job) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Job.Unmarshal(m, b)
}
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Job.Marshal(b, m, deterministic)
}
func (m *Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job.Merge(m, src)
}
func (m *Job) XXX_Size() int {
	return xxx_messageInfo_Job.Size(m)
}
func (m *Job) XXX_DiscardUnknown() {
	xxx_messageInfo_Job.DiscardUnknown(m)
}

var xxx_messageInfo_Job proto.InternalMessageInfo

func (m *Job) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Job) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Job) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *Job) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *Job) GetUsage() map[string]*UsageByClass {
	if m != nil {
		return m.Usage
	}
	return nil
}

func (m *Job) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *Job) GetEntries() int64 {
	if m != nil {
		return m.Entries
	}
	return 0
}

func (m *Job) GetMeepo() string {
	if m != nil {
		return m.Meepo
	}
	return ""
}

type MeepoInstance struct {
	IP                   string   `protobuf:"bytes,1,opt,name=IP,proto3" json:"IP,omitempty"`
	Port                 int32    `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	RunningJobs          int64    `protobuf:"varint,3,opt,name=runningJobs,proto3" json:"runningJobs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MeepoInstance) Reset()         { *m = MeepoInstance{} }
func (m *MeepoInstance) String() string { return proto.CompactTextString(m) }
func (*MeepoInstance) ProtoMessage()    {}
func (*MeepoInstance) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0acbb0c07d5827b, []int{3}
}

func (m *MeepoInstance) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MeepoInstance.Unmarshal(m, b)
}
func (m *MeepoInstance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MeepoInstance.Marshal(b, m, deterministic)
}
func (m *MeepoInstance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeepoInstance.Merge(m, src)
}
func (m *MeepoInstance) XXX_Size() int {
	return xxx_messageInfo_MeepoInstance.Size(m)
}
func (m *MeepoInstance) XXX_DiscardUnknown() {
	xxx_messageInfo_MeepoInstance.DiscardUnknown(m)
}

var xxx_messageInfo_MeepoInstance proto.InternalMessageInfo

func (m *MeepoInstance) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *MeepoInstance) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *MeepoInstance) GetRunningJobs() int64 {
	if m != nil {
		return m.RunningJobs
	}
	return 0
}

func init() {
	proto.RegisterType((*Empty)(nil), "meepo_pb.Empty")
	proto.RegisterType((*UsageByClass)(nil), "meepo_pb.UsageByClass")
	proto.RegisterType((*Job)(nil), "meepo_pb.Job")
	proto.RegisterMapType((map[string]*UsageByClass)(nil), "meepo_pb.Job.UsageEntry")
	proto.RegisterType((*MeepoInstance)(nil), "meepo_pb.MeepoInstance")
}

func init() { proto.RegisterFile("meepo.proto", fileDescriptor_a0acbb0c07d5827b) }

var fileDescriptor_a0acbb0c07d5827b = []byte{
	// 498 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x53, 0x4f, 0x6b, 0xdb, 0x4e,
	0x10, 0xfd, 0x59, 0xb6, 0xfc, 0x67, 0x9c, 0xfc, 0xda, 0x0e, 0x25, 0x11, 0xa6, 0x14, 0xe3, 0x53,
	0x68, 0x83, 0x0e, 0x0e, 0x94, 0x52, 0xe8, 0xc1, 0x4d, 0x73, 0xb0, 0x4b, 0xc1, 0x88, 0xe4, 0xd2,
	0x4b, 0x91, 0xb4, 0x83, 0xba, 0x54, 0xde, 0x15, 0xab, 0x55, 0x40, 0xd7, 0x7e, 0xa1, 0x1e, 0xfa,
	0x05, 0xcb, 0x8e, 0xe4, 0xc8, 0x69, 0x0d, 0xbd, 0xed, 0x9b, 0x79, 0x7a, 0xbb, 0xef, 0xcd, 0x08,
	0xa6, 0x3b, 0xa2, 0x42, 0x87, 0x85, 0xd1, 0x56, 0xe3, 0x98, 0xc1, 0xd7, 0x22, 0x59, 0x8c, 0xc0,
	0xbf, 0xd9, 0x15, 0xb6, 0x5e, 0xfc, 0xf0, 0xe0, 0xe4, 0xae, 0x8c, 0x33, 0xfa, 0x50, 0x5f, 0xe7,
	0x71, 0x59, 0xe2, 0x0c, 0xc6, 0xa5, 0x8d, 0x95, 0x88, 0x8d, 0x08, 0x7a, 0xf3, 0xde, 0x45, 0x3f,
	0x7a, 0xc0, 0x78, 0x09, 0xcf, 0x0c, 0x89, 0x2a, 0x25, 0x11, 0x91, 0xa8, 0x94, 0x88, 0x55, 0x5a,
	0x07, 0x1e, 0x93, 0xfe, 0x6e, 0x60, 0x00, 0xa3, 0x2c, 0x8f, 0x53, 0x49, 0x26, 0xe8, 0x33, 0x67,
	0x0f, 0xf1, 0x25, 0xc0, 0x5e, 0x73, 0xbd, 0x0a, 0x06, 0xdc, 0x3c, 0xa8, 0xe0, 0x0b, 0x98, 0x68,
	0x45, 0x5f, 0xb4, 0xa2, 0xf5, 0x2a, 0xf0, 0xb9, 0xdd, 0x15, 0x30, 0x04, 0x94, 0xca, 0x52, 0x9e,
	0xcb, 0x8c, 0x94, 0xbd, 0x95, 0x64, 0xa4, 0xca, 0x82, 0x21, 0xd3, 0x8e, 0x74, 0x70, 0x0e, 0x53,
	0x41, 0x54, 0xac, 0x4c, 0xfa, 0x4d, 0xde, 0x53, 0x30, 0x62, 0xe2, 0x61, 0x69, 0xf1, 0xd3, 0x83,
	0xfe, 0x46, 0x27, 0xee, 0x5e, 0x2b, 0x77, 0x54, 0xda, 0x78, 0x57, 0xb0, 0xf9, 0x41, 0xd4, 0x15,
	0xf0, 0x7f, 0xf0, 0xa4, 0x68, 0xed, 0x7a, 0x52, 0xb4, 0x49, 0x19, 0xfb, 0x89, 0x6a, 0x36, 0x78,
	0x12, 0x3d, 0x60, 0x3c, 0x83, 0x21, 0x29, 0xe1, 0x3a, 0x03, 0xee, 0xb4, 0x08, 0x43, 0xf0, 0x2b,
	0x97, 0x76, 0xe0, 0xcf, 0xfb, 0x17, 0xd3, 0x65, 0x10, 0xee, 0x27, 0x12, 0x6e, 0x74, 0x12, 0xf2,
	0x20, 0x6e, 0x94, 0x35, 0x75, 0xd4, 0xd0, 0xf0, 0x39, 0xf8, 0x64, 0x8c, 0x36, 0x6c, 0x6f, 0x12,
	0x35, 0xc0, 0x25, 0x4b, 0xca, 0x1a, 0x49, 0x65, 0xeb, 0x66, 0x0f, 0x1d, 0x9f, 0x15, 0x83, 0x71,
	0xc3, 0x67, 0x30, 0xdb, 0x02, 0x74, 0xd2, 0xf8, 0x14, 0xfa, 0xdf, 0xa9, 0x66, 0x7f, 0x93, 0xc8,
	0x1d, 0xf1, 0x12, 0xfc, 0xfb, 0x38, 0xaf, 0x88, 0xcd, 0x4d, 0x97, 0x67, 0xdd, 0xab, 0x0e, 0x57,
	0x23, 0x6a, 0x48, 0xef, 0xbc, 0xb7, 0xbd, 0xc5, 0x1d, 0x9c, 0x7e, 0x76, 0x9c, 0xb5, 0x72, 0x63,
	0x4b, 0xc9, 0x85, 0xb3, 0xde, 0xb6, 0x9a, 0xde, 0x7a, 0x8b, 0x08, 0x83, 0x42, 0x1b, 0xcb, 0x8a,
	0x7e, 0xc4, 0x67, 0x37, 0x08, 0x53, 0x29, 0x25, 0x55, 0xb6, 0xd1, 0x49, 0xd9, 0x2e, 0xc5, 0x61,
	0x69, 0x79, 0x05, 0x3e, 0xcb, 0xe2, 0x2b, 0x18, 0xae, 0x84, 0x70, 0x33, 0x39, 0x7d, 0x14, 0xd1,
	0xec, 0x49, 0x07, 0x9b, 0x05, 0xfe, 0x6f, 0xf9, 0xab, 0xd7, 0x3e, 0x26, 0xa2, 0x4c, 0x96, 0xce,
	0xe1, 0x1b, 0x18, 0x37, 0x67, 0x32, 0x78, 0xde, 0x7d, 0xf0, 0xe8, 0xc5, 0x47, 0x94, 0xf0, 0x35,
	0x8c, 0x36, 0x3a, 0xf9, 0xa8, 0x15, 0xfd, 0xfb, 0x5a, 0x7c, 0x0f, 0xe7, 0xb7, 0x46, 0x66, 0x19,
	0x19, 0x0e, 0xe9, 0x3a, 0xce, 0xd3, 0x2a, 0x8f, 0xad, 0xd4, 0x0a, 0xff, 0x64, 0x1f, 0xf9, 0x3c,
	0x19, 0xf2, 0x2f, 0x79, 0xf5, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x9b, 0x96, 0xaf, 0x8e, 0xa1, 0x03,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MeepoClient is the client API for Meepo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MeepoClient interface {
	AddJob(ctx context.Context, in *Job, opts ...grpc.CallOption) (*Empty, error)
}

type meepoClient struct {
	cc *grpc.ClientConn
}

func NewMeepoClient(cc *grpc.ClientConn) MeepoClient {
	return &meepoClient{cc}
}

func (c *meepoClient) AddJob(ctx context.Context, in *Job, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/meepo_pb.Meepo/AddJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MeepoServer is the server API for Meepo service.
type MeepoServer interface {
	AddJob(context.Context, *Job) (*Empty, error)
}

// UnimplementedMeepoServer can be embedded to have forward compatible implementations.
type UnimplementedMeepoServer struct {
}

func (*UnimplementedMeepoServer) AddJob(ctx context.Context, req *Job) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddJob not implemented")
}

func RegisterMeepoServer(s *grpc.Server, srv MeepoServer) {
	s.RegisterService(&_Meepo_serviceDesc, srv)
}

func _Meepo_AddJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Job)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeepoServer).AddJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/meepo_pb.Meepo/AddJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeepoServer).AddJob(ctx, req.(*Job))
	}
	return interceptor(ctx, in, info, handler)
}

var _Meepo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "meepo_pb.Meepo",
	HandlerType: (*MeepoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddJob",
			Handler:    _Meepo_AddJob_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "meepo.proto",
}

// MeepoRegistryClient is the client API for MeepoRegistry service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MeepoRegistryClient interface {
	Register(ctx context.Context, in *MeepoInstance, opts ...grpc.CallOption) (*Empty, error)
	JobDone(ctx context.Context, in *Job, opts ...grpc.CallOption) (*Empty, error)
	// solely for CLI tools to trigger another usage calculation/publishing,
	// returns nothing
	TriggerUsageCalculation(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type meepoRegistryClient struct {
	cc *grpc.ClientConn
}

func NewMeepoRegistryClient(cc *grpc.ClientConn) MeepoRegistryClient {
	return &meepoRegistryClient{cc}
}

func (c *meepoRegistryClient) Register(ctx context.Context, in *MeepoInstance, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/meepo_pb.MeepoRegistry/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meepoRegistryClient) JobDone(ctx context.Context, in *Job, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/meepo_pb.MeepoRegistry/JobDone", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meepoRegistryClient) TriggerUsageCalculation(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/meepo_pb.MeepoRegistry/TriggerUsageCalculation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MeepoRegistryServer is the server API for MeepoRegistry service.
type MeepoRegistryServer interface {
	Register(context.Context, *MeepoInstance) (*Empty, error)
	JobDone(context.Context, *Job) (*Empty, error)
	// solely for CLI tools to trigger another usage calculation/publishing,
	// returns nothing
	TriggerUsageCalculation(context.Context, *Empty) (*Empty, error)
}

// UnimplementedMeepoRegistryServer can be embedded to have forward compatible implementations.
type UnimplementedMeepoRegistryServer struct {
}

func (*UnimplementedMeepoRegistryServer) Register(ctx context.Context, req *MeepoInstance) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (*UnimplementedMeepoRegistryServer) JobDone(ctx context.Context, req *Job) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JobDone not implemented")
}
func (*UnimplementedMeepoRegistryServer) TriggerUsageCalculation(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerUsageCalculation not implemented")
}

func RegisterMeepoRegistryServer(s *grpc.Server, srv MeepoRegistryServer) {
	s.RegisterService(&_MeepoRegistry_serviceDesc, srv)
}

func _MeepoRegistry_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MeepoInstance)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeepoRegistryServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/meepo_pb.MeepoRegistry/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeepoRegistryServer).Register(ctx, req.(*MeepoInstance))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeepoRegistry_JobDone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Job)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeepoRegistryServer).JobDone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/meepo_pb.MeepoRegistry/JobDone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeepoRegistryServer).JobDone(ctx, req.(*Job))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeepoRegistry_TriggerUsageCalculation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeepoRegistryServer).TriggerUsageCalculation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/meepo_pb.MeepoRegistry/TriggerUsageCalculation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeepoRegistryServer).TriggerUsageCalculation(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _MeepoRegistry_serviceDesc = grpc.ServiceDesc{
	ServiceName: "meepo_pb.MeepoRegistry",
	HandlerType: (*MeepoRegistryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _MeepoRegistry_Register_Handler,
		},
		{
			MethodName: "JobDone",
			Handler:    _MeepoRegistry_JobDone_Handler,
		},
		{
			MethodName: "TriggerUsageCalculation",
			Handler:    _MeepoRegistry_TriggerUsageCalculation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "meepo.proto",
}
