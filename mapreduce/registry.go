package mapreduce

import (
	"context"
	"errors"
	"fmt"
	"github.com/journeymidnight/yig-billing/helper"
	pb "github.com/journeymidnight/yig-billing/mapreduce/proto"
	"github.com/journeymidnight/yig-billing/tikv"
	"google.golang.org/grpc"
	"net"
	"strings"
	"sync"
	"time"
)

const (
	heartbeatInterval = 10 * time.Second
	slowJobThreshold  = 4 * time.Minute
)

func NewRegistry(pdAddresses []string) *MeepoRegistry {
	r := &MeepoRegistry{
		tikvClient:          tikv.NewClient(pdAddresses),
		meepos:              make(map[string]*meepo),
		meepoLock:           sync.Mutex{},
		runningCalculations: make(map[uint64]*calculationHandle),
		calculationLock:     sync.Mutex{},
	}
	go r.supervise()
	return r
}

type meepo struct {
	address     string
	runningJobs int64
	lastSeen    time.Time
	client      pb.MeepoClient
}

// generally there's only 1 running calculation,
// so acquire "calculation" lock for modifying contents in handle
type calculationHandle struct {
	runningJobs []pb.Job                    // job ID -> job
	startTime   []time.Time                 // job ID -> job start time
	finished    map[int64]bool              // job ID -> finished?
	Result      map[string]*pb.UsageByClass // bucket name -> used bytes
	UserBuckets map[string][]string         // user name -> []bucket name
	entries     int64                       // total keys processed by workers
	Done        chan int                    // as a notification of calculation completion
}

type MeepoRegistry struct {
	tikvClient *tikv.TiKVClient

	// IP address -> meepo info
	meepos map[string]*meepo
	// lock for "meepos"
	meepoLock sync.Mutex

	// timestamp -> job controllers,
	// where timestamp is generated by tikv, for transaction
	runningCalculations map[uint64]*calculationHandle
	// lock for "runningCalculations" and "nextCalculationID"
	calculationLock sync.Mutex
}

func stringInSlice(s string, slice []string) bool {
	for _, x := range slice {
		if s == x {
			return true
		}
	}
	return false
}

// Periodically check if meepo heartbeat time out,
// reassign jobs on those meepos randomly.
// Also check if a job takes too long (slowJobThreshold),
// reschedule those jobs.
func (r *MeepoRegistry) supervise() {
	for {
		time.Sleep(heartbeatInterval)

		now := time.Now()
		missingMeepo := make([]string, 0, 10) // IP addresses
		r.meepoLock.Lock()
		for ip, meepo := range r.meepos {
			if now.Sub(meepo.lastSeen) > 2*heartbeatInterval {
				missingMeepo = append(missingMeepo, ip)
			}
		}
		r.meepoLock.Unlock()
		if len(missingMeepo) == 0 {
			helper.Logger.Info("No missing meepo.")
		} else {
			helper.Logger.Warn("Missing meepo:", missingMeepo)
		}

		r.calculationLock.Lock()
		for timestamp, handle := range r.runningCalculations {
			for id, job := range handle.runningJobs {
				if handle.finished[job.Id] {
					continue
				}
				if stringInSlice(job.Meepo, missingMeepo) {

					helper.Logger.Info("Detecting missing job",
						timestamp, id, "on", job.Meepo, ", will reschedule")

					r.meepoLock.Lock()
					r.randomAssign(handle, id, missingMeepo)
					r.meepoLock.Unlock()
					continue
				}
				if now.Sub(handle.startTime[id]) > slowJobThreshold {
					helper.Logger.Info("Detecting slow job",
						timestamp, id, "on", job.Meepo, ", will reschedule")
					r.meepoLock.Lock()
					r.randomAssign(handle, id, []string{job.Meepo})
					r.meepoLock.Unlock()
				}
			}
		}
		r.calculationLock.Unlock()
	}
}

func (r *MeepoRegistry) randomAssign(handle *calculationHandle,
	jobID int, avoidMeepoIPs []string) {

	// since for loop of maps is in random order...
	for ip, meepo := range r.meepos {
		if stringInSlice(ip, avoidMeepoIPs) {
			continue
		}
		handle.runningJobs[jobID].Meepo = ip
		handle.startTime[jobID] = time.Now()
		go addJob(meepo.client, handle.runningJobs[jobID])
		break
	}
}

func addJob(client pb.MeepoClient, job pb.Job) {
	err := helper.WithRetry(10, func() error {
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		_, err := client.AddJob(ctx, &job)
		return err
	})()
	if err != nil {
		helper.Logger.Error("Abandon job", job.Timestamp, job.Id,
			"to", job.Meepo, "error:", err)
	}
}

func (r *MeepoRegistry) CalculateUsage() (*calculationHandle, error) {
	handle := calculationHandle{
		finished:    make(map[int64]bool),
		Result:      make(map[string]*pb.UsageByClass),
		UserBuckets: make(map[string][]string),
	}

	var timestamp uint64
	var err error
	err = helper.WithRetry(5, func() error {
		timestamp, err = r.tikvClient.TxnCli.GetTS(context.Background())
		return err
	})()
	if err != nil {
		helper.Logger.Error("GetTs error:", err)
		return nil, err
	}

	r.calculationLock.Lock()
	defer r.calculationLock.Unlock()

	r.runningCalculations[timestamp] = &handle
	go r.tikvClient.FetchUserBuckets(handle.UserBuckets, timestamp)

	var regions []tikv.Region
	err = helper.WithRetry(3, func() error {
		regions, err = r.tikvClient.GetRegions()
		return err
	})()
	if err != nil {
		helper.Logger.Error("Calculation failed. GetRegions:", err)
		return nil, err
	}

	var unmatchedJobIDs []int64
	r.meepoLock.Lock()
	defer r.meepoLock.Unlock()
	if len(r.meepos) == 0 {
		err = errors.New("no meepo instance registered")
		return nil, err
	}
	for _, region := range regions {
		job := pb.Job{
			Timestamp: timestamp,
			Id:        int64(len(handle.runningJobs)),
			StartKey:  region.StartKey,
			EndKey:    region.EndKey,
		}
		handle.runningJobs = append(handle.runningJobs, job)
		handle.startTime = append(handle.startTime, time.Now())

		leaderIP := strings.Split(region.LeaderAddress, ":")[0]
		leaderMeepo := r.meepos[leaderIP]
		if leaderMeepo == nil ||
			time.Now().Sub(leaderMeepo.lastSeen) > 2*heartbeatInterval {

			unmatchedJobIDs = append(unmatchedJobIDs, job.Id)
			continue
		}
		handle.runningJobs[job.Id].Meepo = leaderIP
		go addJob(leaderMeepo.client, job)
	}
	for _, jobID := range unmatchedJobIDs {
		r.randomAssign(&handle, int(jobID), nil)
	}
	return &handle, nil
}

func (r *MeepoRegistry) Register(ctx context.Context,
	instance *pb.MeepoInstance) (*pb.Empty, error) {

	r.meepoLock.Lock()
	defer r.meepoLock.Unlock()

	if ctx.Err() != nil {
		helper.Logger.Error("Register: client context err:", ctx.Err())
		return &pb.Empty{}, nil
	}

	if _, ok := r.meepos[instance.IP]; !ok {
		ctx, _ = context.WithTimeout(ctx, 3*time.Second)
		address := fmt.Sprintf("%s:%d", instance.IP, instance.Port)
		conn, err := grpc.DialContext(ctx,
			address, grpc.WithInsecure(), grpc.WithBlock())
		if err != nil {
			return &pb.Empty{}, errors.New(
				"cannot connect to " + address + " from registry")
		}
		r.meepos[instance.IP] = &meepo{
			address: address,
			client:  pb.NewMeepoClient(conn),
		}
		helper.Logger.Info("New meepo registered:", address)
	}
	m := r.meepos[instance.IP]
	m.runningJobs = instance.RunningJobs
	m.lastSeen = time.Now()

	return &pb.Empty{}, nil
}

func (r *MeepoRegistry) JobDone(ctx context.Context, job *pb.Job) (*pb.Empty, error) {
	r.calculationLock.Lock()
	defer r.calculationLock.Unlock()

	handle := r.runningCalculations[job.Timestamp]
	if handle == nil { // old calculation, do nothing
		return &pb.Empty{}, nil
	}
	if handle.finished[job.Id] { // duplicate, do nothing
		return &pb.Empty{}, nil
	}
	if len(job.Error) != 0 {
		helper.Logger.Warn("Job", job.Timestamp, job.Id,
			"failed, reschedule. Error:", job.Error)
		r.randomAssign(handle, int(job.Id), []string{job.Meepo})
		return &pb.Empty{}, nil
	}
	handle.finished[job.Id] = true
	handle.runningJobs[job.Id].Usage = job.Usage
	for bucket, usage := range job.Usage {
		if handle.Result[bucket] == nil {
			handle.Result[bucket] = &pb.UsageByClass{}
		}
		handle.Result[bucket].Standard += usage.Standard
		handle.Result[bucket].Glacier += usage.Glacier
		handle.Result[bucket].StandardIA += usage.StandardIA
	}

	handle.entries += job.Entries
	if len(handle.finished) < len(handle.runningJobs) {
		return &pb.Empty{}, nil
	}
	helper.Logger.Info("Calculation", job.Timestamp,
		"finished, total keys processed:", handle.entries)
	close(handle.Done)
	delete(r.runningCalculations, job.Timestamp)
	return &pb.Empty{}, nil
}

func (r *MeepoRegistry) TriggerUsageCalculation(context.Context,
	*pb.Empty) (*pb.Empty, error) {

	go r.CalculateUsage()
	return &pb.Empty{}, nil
}

var Registry *MeepoRegistry

func StartServer() {
	meepoConf := helper.Conf.Meepo
	tikvConf := helper.Conf.Tikv
	helper.Logger.Info(
		"Registry IP:", meepoConf.RegistryAddress, "port:", meepoConf.RegistryPort)

	listener, err := net.Listen("tcp",
		fmt.Sprintf("[::]:%d", meepoConf.RegistryPort))
	if err != nil {
		panic("net.Listen error: " + err.Error())
	}
	grpcServer := grpc.NewServer()
	Registry = NewRegistry(tikvConf.PdAddresses)
	pb.RegisterMeepoRegistryServer(grpcServer, Registry)
	err = grpcServer.Serve(listener)
	helper.Logger.Error("Server stopped with error:", err)
}